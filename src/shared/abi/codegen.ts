#!/usr/bin/env bun

import { existsSync, readFileSync, writeFileSync } from "node:fs"
import path from "node:path"
import { glob } from "glob"

const PATH_TO_GENERATED = path.join(import.meta.dir, "./generated.ts")

if (existsSync(PATH_TO_GENERATED) && process.argv.includes("--no-overwrite")) {
  console.error(`${PATH_TO_GENERATED} already exists, skipping overwrite.`)
  process.exit(0)
}

interface AbiConfig {
  glob: string
  keyPath?: string
  types?: string[]
}

const loadAbi = (cfgs: AbiConfig[]): object => {
  const ret: any[] = []
  const fragments: Record<string, Record<string, any>> = {}

  cfgs.forEach((cfg) => {
    try {
      const files = glob.sync(path.join(import.meta.dir, cfg.glob))

      files.forEach((f: string) => {
        try {
          const content = readFileSync(f, "utf8")
          const j = JSON.parse(content)

          const abi = cfg.keyPath ? getNestedValue(j, cfg.keyPath) : j

          if (abi && Array.isArray(abi)) {
            abi.forEach((f: any) => {
              if (!cfg.types || cfg.types.includes(f.type)) {
                fragments[f.type] = fragments[f.type] || {}
                fragments[f.type][f.name] = f
              }
            })
          }
        } catch (fileErr) {
          console.warn(
            `Warning: Could not process file ${f}:`,
            fileErr instanceof Error ? fileErr.message : fileErr,
          )
        }
      })
    } catch (globErr) {
      console.warn(
        `Warning: Could not find files for pattern ${cfg.glob}:`,
        globErr instanceof Error ? globErr.message : globErr,
      )
    }
  })

  Object.keys(fragments).forEach((type: string) => {
    ret.push(...Object.values(fragments[type]))
  })

  return ret
}

// Helper function to get nested object values (like lodash.get)
const getNestedValue = (obj: any, path: string): any => {
  return path.split(".").reduce((current, key) => current?.[key], obj)
}

try {
  const configPath = path.join(import.meta.dir, "./config.json")
  const config = JSON.parse(readFileSync(configPath, "utf8")) as Record<
    string,
    AbiConfig[]
  >

  const abis = Object.keys(config).reduce(
    (acc, name) => {
      try {
        const abi = loadAbi(config[name])
        acc[name] =
          `const ${name}_ABI = ${JSON.stringify(abi, null, 2)} as const`
        return acc
      } catch (err) {
        console.error(`Error loading ABI for ${name}:`, err)
        // Continue with other ABIs even if one fails
        acc[name] = `const ${name}_ABI = [] as const // Failed to load ABI`
        return acc
      }
    },
    {} as Record<string, string>,
  )

  const generatedContent = `// This file is auto-generated by src/shared/abi/codegen.ts
// Do not edit manually

${Object.values(abis).join("\n\n")}

export enum ContractName {
${Object.keys(abis)
  .map((name) => `  ${name} = '${name}'`)
  .join(",\n")}
}

export const getContractAbi = (name: ContractName) => {
  switch (name) {
${Object.keys(abis)
  .map(
    (name) => `    case ContractName.${name}:
      return ${name}_ABI`,
  )
  .join("\n")}
    default:
      throw new Error(\`Unknown contract name: \${name}\`)
  }
}
`

  writeFileSync(PATH_TO_GENERATED, generatedContent, { flag: "w" })
  console.log("✅ ABI generation completed successfully")
  console.log(`Generated: ${PATH_TO_GENERATED}`)
} catch (error) {
  console.error("❌ ABI generation failed:", error)
  process.exit(1)
}
