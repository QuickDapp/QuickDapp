#!/usr/bin/env bun

import { existsSync, readFileSync, writeFileSync } from "node:fs"
import path from "node:path"
import { glob } from "glob"

const PATH_TO_GENERATED = path.join(import.meta.dir, "./generated.ts")

if (existsSync(PATH_TO_GENERATED) && process.argv.includes("--no-overwrite")) {
  console.error(`${PATH_TO_GENERATED} already exists, skipping overwrite.`)
  process.exit(0)
}

interface AbiConfig {
  glob: string
  keyPath?: string
  types?: string[]
}

const loadAbi = (cfgs: AbiConfig[]): object => {
  const ret: any[] = []
  const fragments: Record<string, Record<string, any>> = {}

  cfgs.forEach((cfg) => {
    try {
      const files = glob.sync(path.join(import.meta.dir, cfg.glob))

      files.forEach((f: string) => {
        try {
          const content = readFileSync(f, "utf8")
          const j = JSON.parse(content)

          const abi = cfg.keyPath ? getNestedValue(j, cfg.keyPath) : j

          if (abi && Array.isArray(abi)) {
            abi.forEach((f: any) => {
              if (
                f?.type &&
                f?.name &&
                (!cfg.types || cfg.types.includes(f.type))
              ) {
                const type = f.type
                const name = f.name
                fragments[type] = fragments[type] || {}
                fragments[type][name] = f
              }
            })
          }
        } catch (fileErr) {
          console.warn(
            `Warning: Could not process file ${f}:`,
            fileErr instanceof Error ? fileErr.message : fileErr,
          )
        }
      })
    } catch (globErr) {
      console.warn(
        `Warning: Could not find files for pattern ${cfg.glob}:`,
        globErr instanceof Error ? globErr.message : globErr,
      )
    }
  })

  Object.keys(fragments).forEach((type: string) => {
    const typeFragments = fragments[type]
    if (typeFragments) {
      ret.push(...Object.values(typeFragments))
    }
  })

  return ret
}

// Helper function to get nested object values (like lodash.get)
const getNestedValue = (obj: any, path: string): any => {
  return path.split(".").reduce((current, key) => current?.[key], obj)
}

try {
  const configPath = path.join(import.meta.dir, "./config.json")
  const config = JSON.parse(readFileSync(configPath, "utf8")) as Record<
    string,
    AbiConfig[]
  >

  const abis = Object.keys(config).reduce(
    (acc, name) => {
      try {
        const abiConfig = config[name]
        if (abiConfig) {
          const abi = loadAbi(abiConfig)
          acc[name] =
            `export const ${name}_ABI = ${JSON.stringify(abi, null, 2)} as const`
        } else {
          acc[name] =
            `export const ${name}_ABI = [] as const // No config found`
        }
        return acc
      } catch (err) {
        console.error(`Error loading ABI for ${name}:`, err)
        // Continue with other ABIs even if one fails
        acc[name] =
          `export const ${name}_ABI = [] as const // Failed to load ABI`
        return acc
      }
    },
    {} as Record<string, string>,
  )

  const generatedContent = `// This file is auto-generated by src/shared/abi/codegen.ts
// Do not edit manually

${Object.values(abis).join("\n\n")}

export enum ContractName {
${Object.keys(abis)
  .map((name) => `  ${name} = '${name}'`)
  .join(",\n")}
}

export const getContractAbi = (name: ContractName) => {
  switch (name) {
${Object.keys(abis)
  .map(
    (name) => `    case ContractName.${name}:
      return ${name}_ABI`,
  )
  .join("\n")}
    default:
      throw new Error(\`Unknown contract name: \${name}\`)
  }
}
`

  writeFileSync(PATH_TO_GENERATED, generatedContent, { flag: "w" })
  console.log("✅ ABI generation completed successfully")
  console.log(`Generated: ${PATH_TO_GENERATED}`)
} catch (error) {
  console.error("❌ ABI generation failed:", error)
  process.exit(1)
}
