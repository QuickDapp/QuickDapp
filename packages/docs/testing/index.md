---
order: 93
icon: BeakerIcon
expanded: true
---

# Testing

QuickDapp includes a robust testing infrastructure built on Bun's native test runner. The system supports parallel test execution with complete database isolation, ensuring tests run quickly without interfering with each other.

The test framework consists of two main parts:

- **Test runner** (`scripts/test.ts`) — Orchestrates parallel test execution, manages database templates, and tracks test durations.
- **Template database** — A pre-configured PostgreSQL database cloned for each test file, avoiding schema setup overhead.

## Parallel execution

Each test file receives its own isolated environment running an instance of the dev server as well as a dedicated test database.

| Resource | Allocation |
|----------|-----------|
| Server port | 54000 + file index |
| Database | `quickdapp_test_{index}` cloned from template |

Before tests run, the runner pushes the schema to a template database (`quickdapp_test`). Each test file then clones this template as a temporary database, runs its tests, and drops the cloned database afterward. This approach provides complete isolation while avoiding the cost of running database migrations for every test file.

The runner uses a sliding window / promise pool       
pattern with a default concurrency of 10, i.e. nore more than 10 tests are running in parallel at any time.
                                                                     As soon as one test completes, the next one starts immediately.

_Note: The concurrency factor of 10 can be adjusted using the `--concurrency` command-line argument._

## Duration-based ordering

The file `tests/test-run-order.json` is generated by the test runner and tracks how long each test file takes to execute. The test runner then orders test files in subsequent test runs by duration (longest first) to optimize parallel execution — starting slow tests early ensures they don't become bottlenecks at the end.

This file is automatically updated after each test run. Commit it to share timing data across the team.

## Command-line options

These are the various command-line options available when running tests:

```shell
bun run test                    # Run all tests
bun run test --pattern auth     # Run matching tests
bun run test --watch            # Watch mode
bun run test --verbose          # Enable debug logging
bun run test --bail             # Stop on first failure
bun run test -c 4               # Set concurrency level
bun run test -f auth.test.ts    # Run specific file
```

## Writing tests

All test files **must** import `@tests/helpers/test-config` as their first import:

```typescript
import "@tests/helpers/test-config"  // Must be first!

import { beforeAll, afterAll, test, expect } from 'bun:test'
import { startTestServer } from '../helpers/server'
```

This import sets `PORT`, `DATABASE_URL`, and `BASE_URL` environment variables before `serverConfig` caches them at module load time. Importing it after other server modules will cause tests to use the wrong port or database.

Here is a more fleshed-out example of a test file:

```typescript
import "@tests/helpers/test-config"

import { beforeAll, afterAll, test, expect } from 'bun:test'
import { startTestServer } from '../helpers/server'
import type { TestServer } from '../helpers/server'

let testServer: TestServer

beforeAll(async () => {
  testServer = await startTestServer()
})

afterAll(async () => {
  await testServer.shutdown()
})

test('health check returns ok', async () => {
  const response = await fetch(`${testServer.url}/health`)
  const data = await response.json()
  expect(data.status).toBe('ok')
})
```

